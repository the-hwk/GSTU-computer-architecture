# Архитектура ЭВМ

### Теория по коду для л.р. №4, №5

```ASM
; указываем компилятору, что код будет использовать инструкции для процессора 
; с архитектурой Intel 80386 или новее. Это позволяет использовать 
; 32-разрядные инструкции, расширенные регистры и адресацию.
.386

; задаем "плоскую" модель памяти (программа будет работать в 32-битном
; защищенном режиме с единым адресным пространством без деления на сегменты),
; stdcall - определяет как параметры передаются в функции: параметры
; передаются через стек и очистка стека после вызова функции выполняется
; вызываемой функцией
.model flat, stdcall

; отключаем автоматическое приведение регистров символов к одному виду
; (например, переменные myVar и MYVAR будут считаться разными)
option casemap:none

; подключаем заголовочный файл и библиотеку
include C:/masm32/include/masm32rt.inc
includelib C:/masm32/lib/masm32rt.lib

; в этой секции определяем переменные
.data
    number  db -34
    title   db "Hello", 0h ; 0h - нулевой байт, который указывает конец строки
    message db "Some message", 0Ah, 0h ; 0Ah - переход на след. строку
    array   db 10 dup(5) ; массив, состоящий из 10-ти 5-ок
    inp_msg db "Input a number: ", 0h
    inp_scn db "%d", 0h
    out_msg db "Output number is %d", 0Ah, 0h
    res_msg db "Result is %d", 0Ah, 0h

    a dd 15
    b dd 97
    m dd -3

; в этой секции определяем неинициализированные переменные
.data?
    unk dd ?

; секция текста программы
.code
main:
    ; вывод данных
    ; вызывается функция crt_printf, в которую передается:
        ; адрес строки, которая может содержать спецификаторы вывода
        ; переменные, которые необходимо вывести
    invoke crt_printf, addr inp_msg

    ; ввод данных
    ; вызывается функция crt_scanf, в которую передается:
        ; адрес строки, которая содержит спецификаторы ввода
        ; адрес переменной, в которую необходимо записать данные
    invoke crt_scanf, addr inp_scn, addr unk

    invoke crt_printf, addr out_msg, unk

    ; пример решения выражения (a + b) * (m - unk)
    ; сначала решаем выражение (1): (a + b)
    ; используем регистр eax
    mov eax, a    ; переносим значение переменной a в регистр eax
    add eax, b    ; выполняем сложение: eax = eax + b

    ; результат сложения нужно сохранить, чтобы в дальнейшем использовать его
    ; используем для этого стек
    push eax

    ; теперь вычисляем выражение (2): (m - unk)
    mov eax, m
    sub eax, unk

    ; теперь необходимо перемножить результаты вычислений выражениий (1) и (2)
    ; результат выражения (1) хранится в стеке
    ; заберем его из стека в регистр ebx
    pop ebx

    ; выражение (1) хранится в регистре ebx, выражение (2) - в eax
    ; выполняем умножение
    imul eax, ebx    ; eax = eax * ebx

    ; переносим резульат умножения в переменную unk
    mov unk, eax

    ; выводим результат
    invoke crt_printf, addr res_msg, unk

    ; завершаем выполнение программы
    invoke ExitProcess, 0
end main
```

**Выполнение деления**

Если аргументом деления является регистр из 4 байт (например `ebx`), то процессор поделит число, старшие биты которого хранит регистр `edx`, а младшие `eax` на значение, хранящееся в регистре `ebx`. Результат от деления запишется в регистр `eax`, а остаток запишется в регистр `edx`.
Для упрощения, мы будем записывать только младшие биты (имейте ввиду, что в таком случае размер переменной составляет 2 байта).

```ASM
mov eax, 100    ; младшие биты
mov edx, 0      ; старшие биты
mov ebx, 3      ; делитель
div ebx         ; выполняем деление
```

### Теория по коду для л.р. №6

```ASM
.386
.model flat, stdcall
option casemap:none



include ../masm32/include/fpu.inc
include ../masm32/include/masm32rt.inc

includelib ../masm32/lib/fpu.lib
includelib ../masm32/lib/masm32rt.lib



.data
    ; для вывода строки с результатами
    message db "Result: %s", 0Ah, 0

    ; для хранения результатов в строковом виде
    res1 db 21 dup(0)
    res2 db 21 dup(0)
    res3 db 21 dup(0)
    res4 db 21 dup(0)
    res5 db 21 dup(0)

    ; переменная уравнения
    x    dd 1.0

    ; доп. переменная-буфер
    tmp  dd 0.0

    ; для хранения результатов
    y1   dt 0.0
    y2   dt 0.0
    y3   dt 0.0
    y4   dt 0.0
    y5   dt 0.0

    ; величина шага
    step dd 4.0



.const
    ; константы уравнения
    op1  dd 2.0
    op2  dd 1.6
    op3  dd 7.0



.code
main:
    ; вычисление Yn = 7 * x^3 / (2 * x^2 + 1.6)
    ; нач. знач. x: 1
    ; шаг: 4

    finit                  ; инициализация регистров FPU

    mov ecx, 5             ; итератор цикла

    cycle:                 ; метка начала цикла

        ; примечание: команды сопроцессора в качестве левого операнда
        ; используют значение на вершине стека сопроцессора (ST) 

        fld x              ; загрузка значения x в вершину стека сопроцессора
        fmul x             ; x^2 (x тот, который находится в стеке)
        fmul x             ; x^3
        fmul op3           ; 7 * x^3

        ; в стеке хранится результат вычисления 7 * x^3

        fld x              ; загрузка значения x в вершину стека сопроцессора
        fmul x             ; x^2
        fmul op1           ; 2 * x^2
        fadd op2           ; 2 * x^2 + 1.6

        ; в стеке теперь хранятся следующие величины:
        ; 2 * x^2 + 1.6 (вершина стека)
        ; 7 * x^3

        fstp tmp           ; выгрузка вершины стека в переменную-буфер
        fdiv tmp           ; 7 * x^3 / (2 * x^2 + 1.6)

        fld x              ; загрузка значения x в вершину стека сопроцессора
        fadd step          ; увеличение x на величину шага
        fstp x             ; выгрузка вершины стека в память

        ; результат вычисления выражения на каждой
        ; итерации цикла будет сохраняться на стеке

        loop cycle         ; если exc = exc - 1 != 0,
                           ; то переход на след. итерацию цикла
                           ; (изменение итератора цикла
                           ; выполняется автоматически)

    ; выгрузка всего стека в память
    fstp y5
    fstp y4
    fstp y3
    fstp y2
    fstp y1

    ; преобразование float в string и вывод
    invoke FpuFLtoA, addr y1, 3, addr res1, SRC1_REAL or SRC2_DIMM
    invoke crt_printf, addr message, addr res1

    invoke FpuFLtoA, addr y2, 3, addr res2, SRC1_REAL or SRC2_DIMM
    invoke crt_printf, addr message, addr res2

    invoke FpuFLtoA, addr y3, 3, addr res3, SRC1_REAL or SRC2_DIMM
    invoke crt_printf, addr message, addr res3

    invoke FpuFLtoA, addr y4, 3, addr res4, SRC1_REAL or SRC2_DIMM
    invoke crt_printf, addr message, addr res4

    invoke FpuFLtoA, addr y5, 3, addr res5, SRC1_REAL or SRC2_DIMM
    invoke crt_printf, addr message, addr res5
	
    invoke ExitProcess, 0
end main
```
