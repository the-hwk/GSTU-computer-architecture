# Архитектура ЭВМ

### Теория по коду

```Asm
; указываем компилятору, что код будет использовать инструкции для процессора 
; с архитектурой Intel 80386 или новее. Это позволяет использовать 
; 32-разрядные инструкции, расширенные регистры и адресацию.
.386

; задаем "плоскую" модель памяти (программа будет работать в 32-битном
; защищенном режиме с единым адресным пространством без деления на сегменты),
; stdcall - определяет как параметры передаются в функции: параметры
; передаются через стек и очистка стека после вызова функции выполняется
; вызываемой функцией
.model flat, stdcall

; отключаем автоматическое приведение регистров символов к одному виду
; (например, переменные myVar и MYVAR будут считаться разными)
option casemap:none

; подключаем заголовочный файл и библиотеку
include C:/masm32/include/masm32rt.inc
includelib C:/masm32/lib/masm32rt.lib

; в этой секции определяем переменные
.data
    number  db -34
    title   db "Hello", 0h ; 0h - нулевой байт, который указывает конец строки
    message db "Some message", 0Ah, 0h ; 0Ah - переход на след. строку
    array   db 10 dup(5) ; массив, состоящий из 10-ти 5-ок
    inp_msg db "Input a number: ", 0h
    inp_scn db "%d", 0h
    out_msg db "Output number is %d", 0Ah, 0h
    res_msg db "Result is %d", 0Ah, 0h

    a dd 15
    b dd 97
    m dd -3

; в этой секции определяем неинициализированные переменные
.data?
    unk dd ?

; секция текста программы
.code
main:
    ; вывод данных
    ; вызывается функция crt_printf, в которую передаеся:
        ; адрес строки, которая может содержать спецификаторы вывода
        ; переменные, которые необходимо вывести
    invoke crt_printf, addr inp_msg

    ; ввод данных
    ; вызывается функция crt_scanf, в которую передается:
        ; адрес строки, которая содержит спецификаторы ввода
        ; адрес переменной, в которую необходимо записать данные
    invoke crt_scanf, addr inp_scn, addr unk

    invoke crt_printf, addr out_msg, unk

    ; пример решения выражения (a + b) * (m - unk)
    ; сначала решаем выражение (1): (a + b)
    ; используем регистр eax
    mov eax, a    ; переносим значение переменной a в регистр eax
    add eax, b    ; выполняем сложение: eax = eax + b

    ; результат сложения нужно сохранить, чтобы в дальнейшем его использовать
    ; используем для этого стек
    push eax

    ; теперь вычисляем выражение (2): (m - unk)
    mov eax, m
    sub eax, unk

    ; теперь необходимо перемножить результаты вычислений выражениий (1) и (2)
    ; результат выражения (1) хранится в стеке
    ; заберем его из стека в регистр ebx
    pop ebx

    ; выражение (1) хранится в регистре ebx, выражение (2) - в eax
    ; выполняем умножение
    imul eax, ebx    ; eax = eax * ebx

    ; переносим резульат умножения в переменную unk
    mov unk, eax

    ; выводим результат
    invoke crt_printf, addr res_msg, unk

    ; завершаем выполнение программы
    invoke ExitProcess, 0
end main
```
